os.loadAPI("apis/events")
os.loadAPI("apis/net")
os.loadAPI("apis/dns")
os.loadAPI("apis/serializer")
local github = dofile("apis/github")

-- Version calculations
function parseVersion(version)
	local parsed = {}
	version:gsub("(%d+)", function(match) table.insert(parsed, tonumber(match)) end)
	return parsed
end

function compareVersions(versionA, versionB)
	-- TODO: Doesn't handle trailing zeroes correctly. Could iterate through max(#a, #b).
	-- We should probably just imagine that the versions both have an unlimited number of 
	-- trailing zeroes.
	local a = parseVersion(versionA)
	local b = parseVersion(versionB)
	for i, aPart in ipairs(a) do
		local bPart = b[i]
		if bPart == nil then
			return 1 -- More numbers means a is a later version.
		else
			if aPart < bPart then
				return -1
			elseif aPart > bPart then
				return 1
			end
		end
	end
	-- If they are equal so far but b has more numbers, b is later.
	if #b > #a then
		return -1
	end
	return 0
end

-- Local repositories
local Repository.local = {}
Repository.local.__index = Repository.local
Repository.local.new = function(data)
	return setmetatable({path = data.path or "/packages"}, Repository.local)
end
Repository.local.getPackageRootPath = function(self, packageId)
	return fs.combine(self.path, packageId.name)
end
Repository.local.getPackagePath = function(self, packageId)
	return fs.combine(self:getPackageRootPath(packageId), packageId.version)
end
Repository.local.getAllVersions = function(self, packageId)
	local path = self:getPackageRootPath(packageId)
	if fs.isDir(path) then
		return fs.list(path)
	end
end
Repository.local.getLatestVersion = function(self, packageId)
	local versions = self:getAllVersions(packageId)
	if versions == nil then
		return
	end
	local latest
	for _, version in pairs(versions) do
		if latest == nil or compareVersions(latest, version) < 0 then
			latest = version
		end
	end
	return latest
end
local function loadFilesIn(path)
	local files = fs.list(path)
	local fileData = {}
	for _, v in pairs(files) do
		local filePath = fs.combine(path, v)
		if fs.isDir(filePath) then
			fileData[v] = loadFilesIn(filePath)
		else
			local file = fs.open(filePath, "r")
			fileData[v] = net.encode(file.readAll())
			file.close()
		end
	end
	return fileData
end
Repository.local.readPackage = function(self, packageId)
	local path = self:getPackagePath(packageId)
	if fs.isDir(path) then
		-- TODO: Extract manifest handling out of repository code.
		-- TODO: Remove the manifest from the contents everywhere.
		local manifest = serializer.readFromFile(fs.combine(path, "manifest"))
		return {id = packageId, contents = loadFilesIn(path), manifest = manifest}
	end
end
Repository.local.bindPackageId = function(self, packageId)
	local version = packageId.version
	if version == nil then
		version = self:getLatestVersion(packageId)
	end
	if version == nil then
		return nil
	end
	return {name = packageId.name, version = version}
end
Repository.local.bindPackage = function(self, packageId)
	local package = self:bindPackageId(packageId)
	if package ~= nil then
		return self:readPackage(package)
	end
end

-- GitHub repositories
local Repository.GitHub = {}
Repository.GitHub.__index = Repository.GitHub
Repository.GitHub.new = function(data)
	local auth
	if data.auth then
		auth = github.Auth.new(data.auth.type, data.auth.user, data.auth.token)
	end
	local repo = github.repo(data.user, data.name, auth)
	return setmetatable({
		repo = repo,
		defaultVersion = data.defaultVersion,
		path = data.path or "src"
	}, Repository.GitHub)
end
Repository.GitHub.bindPackageId = function(self, packageId)
	local version = packageId.version
	local tree
	if version == nil then
		if self.defaultVersion then
			version = self.defaultVersion
			tree = self.repo:tree(version)
		else
			local release = self.repo:latestRelease()
			version = release.tag
			tree = release:tree()
		end
	else
		local release = self.repo:releaseByTag(version)
		tree = release:tree()
	end
	return version, tree
end
Repository.GitHub.bindPackage = function(self, packageId)
	local version, tree = self:bindPackageId(packageId)
	local repoRoot = tree:getChild(self.path)
	if repoRoot == nil then
		print(string.format("ERROR: Unable to locate repository root %s", self.path))
		return
	end
	local packageTree = repoRoot:getChild(packageId.name)
	if packageTree == nil then
		return
	end
	
	local contents = {}
	packageTree:copyTo(contents, nil, net.encode)
	local manifest = {}
	if contents.manifest then
		manifest = textutils.unserialize(net.decode(contents.manifest))
	end
	return {
		id = {name = packageId.name, version = version},
		contents = contents,
		manifest = manifest
	}
end

-- Package bundling
-- TODO: Extract package ID, package, and package bundle concepts.
function formatPackageId(packageId)
	local result = packageId.name
	if packageId.version ~= nil then
		-- TODO: Revisit this - use a different character to separate name & version.
		result = result .. "-" .. packageId.version
	end
	return result
end

function packageSatisfies(package, packageId)
	if package.id.name ~= packageId.name then
		return false
	end
	if packageId.version == nil then
		return true
	end
	return compareVersions(packageId.version, package.id.version) == 0
end

function bundleContains(msg, packageId)
	for _, package in pairs(msg) do
		if packageSatisfies(package, packageId) then
			return true
		end
	end
	return false
end

function bindPackage(packageId)
	for _, repoConfig in pairs(repositories) do
		-- TODO: Instantiate these when reading the config files on startup.
		local repo = Repository[repoConfig.type].new(repoConfig)
		local result = repo:bindPackage(packageId)
		if result ~= nil then
			return result
		end
	end
end

function bundlePackage(msg, packageId)
	if bundleContains(msg, packageId) then
		return
	end
	local package = bindPackage(packageId)
	if package == nil then
		-- TODO: Return an error along with the resolved packages to the client.
		print(string.format("ERROR: Unable to locate package %s; ignoring it", formatPackageId(packageId)))
		return
	end
	table.insert(msg, package)
	bundlePackages(msg, package.manifest.dependencies)
end

function bundlePackages(msg, toPackage)
	if toPackage == nil then
		return
	end
	for _, packageId in pairs(toPackage) do
		bundlePackage(msg, packageId)
	end
end

function getBundle(toPackage)
	local bundle = {}
	bundlePackages(bundle, toPackage)
	return bundle
end

function sendPackages(args, sender)
	print(string.format("Sending %i packages to %i", #args[2], sender))
	net.sendMessage(sender, "bundleDownload", getBundle(args[2]))
end

-- Update broadcasting
function deployUpdate(toDeploy)
	if toDeploy == nil or toDeploy == "updates" then
		-- Deploy updates to the update server first.
		print("Installing update server update...")
		serializer.writeToFile("/state", {broadcastOnStartup = (toDeploy == nil), updateToDeploy = toDeploy})
		return net.installBundle(getBundle({{name = "updates"}}))
	else
		broadcastUpdate(toDeploy)
	end
end

function broadcastUpdate(toDeploy)
	local updating = "global"
	if toDeploy ~= nil then
		updating = toDeploy
	end
	print(string.format("Broadcasting availability of system update: %s", updating))
	rednet.broadcast({"packageUpdateAvailable", toDeploy})
end

-- Startup
function readState()
	repositories = serializer.readFromFile("/repositories")

	local state = serializer.readFromFile("/state")
	if state.broadcastOnStartup then
		broadcastUpdate(state.updateToDeploy)
	end
	fs.delete("/state")
end

function onStartup()
	net.registerRawMessageHandler("sendPackages", sendPackages)
	net.registerMessageHandler("deployUpdate", deployUpdate)
	net.removeHandler("packageUpdateAvailable") -- We deploy our own updates.

	print(string.format("Amber: Listening on %s...", net.openModem(config.modem)))
	dns.register("updates")
	readState()
end

dofile("config")
onStartup()
events.runParallelMessageLoop()