-- If we're running off a disk, we want to load all of the APIs from the disk, not the computer,
-- to ensure that they are compatible with this code.
-- TODO: Side-by-side loading (we could just embed all dependencies into this file).
if os.originalLoadAPI == nil then
	os.originalLoadAPI = os.loadAPI
	local dir = fs.getDir(shell.getRunningProgram())
	os.loadAPI = function(api)
		os.originalLoadAPI(fs.combine(dir, api))
	end
end

os.loadAPI("apis/events")
os.loadAPI("apis/net")
os.loadAPI("apis/amber")

-- Connect to an Amber server by default.
-- Load the configuration from the program's location, but update the current folder.
local client = amber.PackageClient.fromConfigurationPath(fs.getDir(shell.getRunningProgram()), {{type = "AmberServer"}})
local installation = amber.PackageInstallation.new(
	shell.dir(),
	-- Edit template files interactively.
	function(file) shell.run("edit", "/" .. file) end,
	function(progress) print(progress) end
)

local function createPackageIds(names)
	local ids = {}
	for _, name in ipairs(names) do
		table.insert(ids, {name = name})
	end
	return ids
end

local commands = {
	install = function(args)
		if next(args) == nil then
			return false
		end
		installation:installPackages(client, createPackageIds(args))
	end,
	update = function(args)
		local toUpdate
		if next(args) ~= nil then
			toUpdate = createPackageIds(args)
		end
		installation:updatePackages(client, toUpdate)
	end,
	remove = function(args)
		if next(args) == nil then
			return false
		end
		installation:removePackages(createPackageIds(args))
	end,
	search = function(args)
		local packages = client:getAvailablePackages()
		for name, package in pairs(packages) do
			if args[1] == nil or name:find(args[1]) then
				print(amber.formatPackageId(package.id))
			end
		end
	end,
	nugget = function(args)
		if #args < 2 then
			return false
		end
		local op = args[1]
		local opAction = {
			save = function(packageId, nugget) 
				nugget:writeTo(fs.combine(shell.dir(), packageId))
				print(string.format("%s nugget saved.", packageId))
			end,
			run = function(packageId, nugget, args)
				nugget:run(table.unpack(args))
			end
		}[op]
		if opAction == nil then
			return false
		end
		local packageId = args[2]
		local nugget, errorMessage = client:buildNuggetFor({name = packageId}, packageId)
		if nugget == nil then
			print(string.format("ERROR: %s", errorMessage))
		end
		opAction(packageId, nugget, select(3, table.unpack(args)))
	end
}

-- TODO: Do we need this? We might be performing a local operation only.
net.openModem()
local action = select(1, ...)
local args = {select(2, ...)}
if action == nil or commands[action] == nil or commands[action](args) == false then
	print("Usage:")
	print("amber install <package1> <package2>...")
	print("  Installs or updates specified packages.")
	print("amber update [<package1> <package2>...]")
	print("  Updates specified or all installed packages.")
	print("amber remove <package1> <package2>...")
	print("  Removes specified packages.")
	print("amber search [<pattern>]")
	print("  Lists all available packages, or just those matching <pattern>.")
	print("amber nugget save <package>")
	print("  Save nugget to a file with the same name.")
	print("amber nugget run <package> ...")
	print("  Runs nugget with provided arguments.")
end