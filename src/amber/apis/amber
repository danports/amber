os.loadAPI("apis/serializer")
os.loadAPI("apis/net")
os.loadAPI("apis/version")

-- Package bundling
-- TODO: Extract package ID, package, and package bundle concepts.
function formatPackageId(packageId)
	local result = packageId.name
	if packageId.version ~= nil then
		-- TODO: Revisit this - use a different character to separate name & version.
		result = result .. "-" .. packageId.version
	end
	return result
end

function packageSatisfies(package, packageId)
	if package.id.name ~= packageId.name then
		return false
	end
	if packageId.version == nil then
		return true
	end
	return version.new(packageId.version):compareTo(version.new(package.id.version)) == 0
end

function bundleContains(msg, packageId)
	for _, package in pairs(msg) do
		if packageSatisfies(package, packageId) then
			return true
		end
	end
	return false
end

function bundlePackage(msg, packageId)
	if bundleContains(msg, packageId) then
		return
	end
	local package = bindPackage(packageId)
	if package == nil then
		-- TODO: Return an error along with the resolved packages to the client.
		print(string.format("ERROR: Unable to locate package %s; ignoring it", formatPackageId(packageId)))
		return
	end
	table.insert(msg, package)
	bundlePackages(msg, package.manifest.dependencies)
end

function bundlePackages(msg, toPackage)
	if toPackage == nil then
		return
	end
	for _, packageId in pairs(toPackage) do
		bundlePackage(msg, packageId)
	end
end

function getBundle(toPackage)
	local bundle = {}
	bundlePackages(bundle, toPackage)
	return bundle
end

-- Package binding
local repositories = {}

function bindPackage(packageId)
	for _, repo in pairs(repositories) do
		local result = repo:bindPackage(packageId)
		if result ~= nil then
			return result
		end
	end
end

function initializeClient(defaultConfig)
	local repoConfigs = serializer.readFromFile("/.repositories")
	if next(repoConfigs) == nil and defaultConfig ~= nil then
		repoConfigs = defaultConfig
	end
	
	-- TODO: Load these lazily (we might not need them all).
	local repoTypes = {}
	for _, path in pairs(fs.list("/apis/amber-repositories")) do
		repoTypes[path] = dofile(fs.combine("/apis/amber-repositories", path))
	end
	for _, repoConfig in pairs(repoConfigs) do
		table.insert(repositories, repoTypes[repoConfig.type].new(repoConfig))
	end
end

-- Local package installation
-- TODO: Introduce the concept of a local package installation.
-- Then have operations like install, remove, etc. on the local installation.
local packageRepository = ""

function setPackageRepository(path)
	packageRepository = path
end

function encode(data)
	-- TODO: Eliminate this - it shouldn't be necessary anymore. Have to do that carefully to avoid breaking existing systems.
	return string.gsub(string.gsub(string.gsub(string.gsub(data, "@", "@0"), "\n", "@1"), "\"", "@2"), "\\", "@3")
end

function decode(data)
	return string.gsub(string.gsub(string.gsub(string.gsub(data, "@1", "\n"), "@2", "\""), "@3", "\\"), "@0", "@")
end

function requestPackages(packages)
	local bundle = getBundle(packages)
	installBundle(bundle)
end

function getPackageListPath()
	return fs.combine(packageRepository, "packageList")
end

function getInstalledPackageNames()
	return serializer.readFromFile(getPackageListPath())
end

function updatePackages(availableNow)
	local installed = getInstalledPackageNames()
	if installed == nil then
		return
	end
	local toRequest = {}
	for _, pkg in pairs(installed) do
		if availableNow == nil or availableNow == pkg.name then
			table.insert(toRequest, {name = pkg.name})
		end
	end
	requestPackages(toRequest)
end

local editHandler

function setEditHandler(handler)
	editHandler = handler
end

function writePackageFiles(path, data)
	local rebootNeeded = false
	if not fs.isDir(path) then
		fs.makeDir(path)
	end
	for file, contents in pairs(data) do
		local destination = fs.combine(path, file)
		if type(contents) == "table" then
			rebootNeeded = writePackageFiles(destination, contents) or rebootNeeded
		else
			if file == "startup" then
				rebootNeeded = true
			end
			local writeTo = destination
			local editFile = false
			if destination:sub(-2) == ".t" then
				local baseName = destination:sub(1, #destination - 2)
				if not fs.exists(baseName) then
					writeTo = baseName
					editFile = true
					print(string.format("%s => %s", destination, writeTo))
				else
					print(writeTo)
				end
			else
				print(writeTo)
			end
			local file = fs.open(writeTo, "w")
			file.write(decode(contents))
			file.close()
			if editFile and editHandler ~= nil then
				print(string.format("Editing: %s", writeTo))
				editHandler(writeTo)
			end
		end
	end
	return rebootNeeded
end

function installPackage(package)
	print(string.format("Installing package %s-%s...", package.id.name, package.id.version))
	local result = writePackageFiles(packageRepository, package.contents)
	local installed = getInstalledPackageNames()
	-- TODO: We need to indicate which packages the user installed and which we added as dependencies.
	installed[package.id.name] = package.id
	serializer.writeToFile(getPackageListPath(), installed)
	return result
end

function installBundle(bundle)
	local rebootNeeded = false
	for _, package in pairs(bundle) do
		rebootNeeded = installPackage(package) or rebootNeeded
	end
	if rebootNeeded then
		print("Rebooting in 3 seconds...")
		os.sleep(3)
		os.reboot()
	end
	return false
end