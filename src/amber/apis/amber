os.loadAPI("apis/serializer")
os.loadAPI("apis/net")
os.loadAPI("apis/version")

-- TODO: Extract package ID, package, and package bundle concepts.
function formatPackageId(packageId)
	local result = packageId.name
	if packageId.version ~= nil then
		-- TODO: Revisit this - use a different character to separate name & version.
		result = result .. "-" .. packageId.version
	end
	return result
end

-- Package binding
PackageClient = {}
PackageClient.__index = PackageClient
PackageClient.new = function(repoConfigs, repoTypesPath)
	local repositories = {}
	local repoTypes = {}
	for _, repoConfig in pairs(repoConfigs) do
		local repoType = repoTypes[repoConfig.type]
		if repoType == nil then
			-- TODO: Better error handling.
			repoType = dofile(fs.combine(repoTypesPath, repoConfig.type))
			repoTypes[repoConfig.type] = repoType
		end
		table.insert(repositories, repoType.new(repoConfig))
	end

	return setmetatable({repositories = repositories}, PackageClient)
end
PackageClient.fromConfigurationPath = function(path, defaultConfig)
	path = path or ""
	local repoConfigs = serializer.readFromFile(fs.combine(path, ".repositories"))
	if next(repoConfigs) == nil and defaultConfig ~= nil then
		repoConfigs = defaultConfig
	end
	return PackageClient.new(repoConfigs, fs.combine(path, "apis/amber-repositories"))
end
local function createPackage(package)
	if not package.manifest then
		-- TODO: The latter is a legacy path for backwards compatibility.
		-- Remove it after all packages have been migrated to the new format.
		local paths = {".manifest", "manifest"}
		for _, path in ipairs(paths) do
			local contents = package.contents[path]
			if contents then
				package.manifest = textutils.unserialize(contents)
				package.contents[path] = nil
				break
			end
		end
		if not package.manifest then
			package.manifest = {}
		end
	end
	return package
end
PackageClient.bindPackage = function(self, packageId)
	for _, repo in pairs(self.repositories) do
		local result = repo:bindPackage(packageId)
		if result ~= nil then
			return createPackage(result)
		end
	end
end
local function isSatisfiedBy(specId, packageId)
	if specId.name ~= packageId.name then
		return false
	end
	if specId.version == nil then
		return true
	end
	return version.new(specId.version):compareTo(version.new(packageId.version)) == 0
end
local function bundleContains(msg, packageId)
	for _, package in pairs(msg) do
		if isSatisfiedBy(packageId, package.id) then
			return true
		end
	end
	return false
end
PackageClient.bundlePackage = function(self, msg, packageId, userInstalled)
	if bundleContains(msg, packageId) then
		return
	end
	local package = self:bindPackage(packageId)
	if package == nil then
		return {errorMessage = string.format("Unable to locate package %s", formatPackageId(packageId))}
	end
	package.userInstalled = userInstalled
	table.insert(msg, package)
	self:bundlePackages(msg, package.manifest.dependencies, nil)
end
PackageClient.bundlePackages = function(self, msg, toPackage, userInstalled)
	if toPackage == nil then
		return
	end
	for _, packageId in pairs(toPackage) do
		self:bundlePackage(msg, packageId, userInstalled)
	end
end
PackageClient.getBundle = function(self, toPackage, userInstalled)
	local bundle = {}
	self:bundlePackages(bundle, toPackage, userInstalled)
	return bundle
end
PackageClient.getAvailablePackages = function(self)
	local packages = {}
	for _, repo in pairs(self.repositories) do
		for name, packageInfo in pairs(repo:getAvailablePackages()) do
			if packages[name] == nil then
				packages[name] = packageInfo
			end
		end
	end
	return packages
end

-- Local package installation
-- TODO: Add other operations like list, info, etc. on the installation/client.
PackageInstallation = {}
PackageInstallation.__index = PackageInstallation
PackageInstallation.new = function(path, onEdit, onProgress)
	return setmetatable({
		path = path or "",
		onEdit = onEdit,
		onProgress = onProgress or function() end
	}, PackageInstallation)
end
PackageInstallation.getPackageListPaths = function(self)
	-- TODO: The latter path is a legacy one that exists only for backwards compatibility.
	return {fs.combine(self.path, ".packages"), fs.combine(self.path, "packageList")}
end
PackageInstallation.getInstalledPackages = function(self)
	for _, path in ipairs(self:getPackageListPaths()) do
		local contents = serializer.readFromFile(path)
		if next(contents) ~= nil then
			if contents.version == nil then
				-- Upgrade v0 package lists.
				local newContents = {version = 1, packages = {}}
				for k, v in pairs(contents) do
					newContents.packages[k] = {id = v}
				end
				return newContents
			end
			return contents
		end
	end
	return {version = 1, packages = {}}
end
PackageInstallation.writePackageFiles = function(self, path, data, allFiles)
	local rebootNeeded = false
	if not fs.isDir(path) then
		fs.makeDir(path)
	end
	for file, contents in pairs(data) do
		local destination = fs.combine(path, file)
		if type(contents) == "table" then
			rebootNeeded = self:writePackageFiles(destination, contents, allFiles) or rebootNeeded
		else
			if file == "startup" then
				rebootNeeded = true
			end
			local writeTo = destination
			allFiles[writeTo] = {}
			local editFile = false
			-- TODO: Write to the template file AND copy it to the destination path if it does not exist.
			-- That way we can detect changes to the file when a new version is installed.
			if destination:sub(-2) == ".t" then
				local baseName = destination:sub(1, #destination - 2)
				if not fs.exists(baseName) then
					writeTo = baseName
					editFile = true
					self.onProgress(string.format("  %s => %s", destination, writeTo))
				else
					self.onProgress(string.format("  %s", writeTo))
				end
			else
				self.onProgress(string.format("  %s", writeTo))
			end
			local file = fs.open(writeTo, "w")
			file.write(contents)
			file.close()
			if editFile and self.onEdit ~= nil then
				self.onProgress(string.format("  Editing: %s", writeTo))
				self.onEdit(writeTo)
			end
		end
	end
	return rebootNeeded
end
local function extractPackageMetadata(package, allFiles)
	local metadata = {}
	for k, v in pairs(package) do
		if k == "contents" then
			metadata[k] = allFiles
		else
			metadata[k] = v
		end
	end
	return metadata
end
PackageInstallation.writeInstalledPackages = function(self, installed)
	local paths = self:getPackageListPaths()
	serializer.writeToFile(paths[1], installed)
	-- Clean up legacy package lists.
	for i = 2, #paths do
		fs.delete(paths[i])
	end
end
PackageInstallation.installPackage = function(self, package)
	if package.errorMessage ~= nil then
		-- TODO: onError callback.
		self.onProgress(string.format("ERROR: %s", package.errorMessage))
		return
	end
	
	self.onProgress(string.format("Installing package %s...", formatPackageId(package.id)))
	local installed = self:getInstalledPackages()
	local existing = installed.packages[package.id.name] or {}
	
	local filesWritten = {}
	local result = self:writePackageFiles(self.path, package.contents, filesWritten)
	-- TODO: This check is only needed for legacy package lists.
	if existing.contents ~= nil then
		for existingFile in pairs(existing.contents) do
			if filesWritten[existingFile] == nil then
				self.onProgress(string.format("  Removing obsolete file: %s", existingFile))
				fs.delete(existingFile)
			end
		end
	end
	
	local newMetadata = extractPackageMetadata(package, filesWritten)
	newMetadata.userInstalled = newMetadata.userInstalled or existing.userInstalled
	installed.packages[package.id.name] = newMetadata
	self:writeInstalledPackages(installed)
	
	return result
end
PackageInstallation.installBundle = function(self, bundle)
	local rebootNeeded = false
	for _, package in pairs(bundle) do
		rebootNeeded = self:installPackage(package) or rebootNeeded
	end
	if rebootNeeded then
		self.onProgress("Rebooting...")
		os.sleep(3)
		os.reboot()
	end
end
PackageInstallation.installPackagesCore = function(self, client, packages, userInstalled)
	local bundle = client:getBundle(packages, userInstalled)
	self:installBundle(bundle)
end
PackageInstallation.installPackages = function(self, client, packages, userInstalled)
	if userInstalled == nil then
		userInstalled = true
	end
	self.onProgress(string.format("Installing %i packages...", #packages))
	self:installPackagesCore(client, packages, userInstalled)
end
local function packageIdListContains(packages, packageId)
	for _, id in pairs(packages) do
		-- We don't check the version since that's not relevant for upgrades.
		if id.name == packageId.name then
			return true
		end
	end
	return false
end
PackageInstallation.getInstalledPackage = function(self, packageId)
	local installed = self:getInstalledPackages()
	for _, pkg in pairs(installed.packages) do
		if isSatisfiedBy(packageId, pkg.id) then
			return pkg
		end
	end
end
PackageInstallation.updatePackages = function(self, client, packages)
	local installed = self:getInstalledPackages()
	local toRequest = {}
	for _, pkg in pairs(installed.packages) do
		if packages == nil or packageIdListContains(packages, pkg.id) then
			table.insert(toRequest, {name = pkg.id.name})
		end
	end
	if next(toRequest) == nil then
		return
	end
	self.onProgress(string.format("Updating %i packages...", #toRequest))
	self:installPackagesCore(client, toRequest, false)
end
PackageInstallation.removePackage = function(self, package)
	self.onProgress(string.format("Removing package %s...", formatPackageId(package)))
	local installed = self:getInstalledPackages()
	local existing = installed.packages[package.name]
	if existing == nil then
		local message = string.format("ERROR: Package %s not installed", formatPackageId(package))
		self.onProgress(message)
		return false, message
	end

	for existingFile in pairs(existing.contents) do
		-- TODO: What about template files?
		-- TODO: What about empty directories?
		-- TODO: What if this package is needed by others?
		-- TODO: What about purging dependencies which are no longer needed?
		self.onProgress(string.format("  Removing: %s", existingFile))
		fs.delete(existingFile)
	end
	
	installed.packages[package.name] = nil
	self:writeInstalledPackages(installed)

	return true
end
PackageInstallation.removePackages = function(self, packages)
	self.onProgress(string.format("Removing %i packages...", #packages))
	for _, package in ipairs(packages) do
		self:removePackage(package)
	end
end